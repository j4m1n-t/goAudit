package crud

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	serverSide "github.com/j4m1n-t/goAudit/goAuditServer/pkg"
)

func InitDB() error {
	SQLSettings := serverSide.LoadSQLSettings()

	connString := fmt.Sprintf("postgres://%s:%s@%s:%s/%s",
		SQLSettings.User, SQLSettings.Password, SQLSettings.Server, SQLSettings.Port, SQLSettings.Database)

	var err error
	dbPool, err = pgxpool.New(context.Background(), connString)
	if err != nil {
		return fmt.Errorf("failed to connect to database: %v", err)
	}

	err = dbPool.Ping(context.Background())
	if err != nil {
		dbPool.Close()
		return fmt.Errorf("failed to ping database: %v", err)
	}

	log.Println("Successfully connected to database.")

	if err := EnsureTableExists(); err != nil {
		return fmt.Errorf("failed to ensure table exists: %v", err)
	}

	return nil
}

func EnsureTableExists() error {
	createTableSQL := `
    CREATE TABLE IF NOT EXISTS generic_table (
        id SERIAL PRIMARY KEY,
        -- Add other fields specific to each type
        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
        user_id INTEGER NOT NULL,
        user_name TEXT
    );`

	_, err := dbPool.Exec(context.Background(), createTableSQL)
	if err != nil {
		return fmt.Errorf("failed to create table: %v", err)
	}
	return nil
}

func Create(item Generic) (Generic, error) {
	query := `INSERT INTO generic_table (/* fields */, user_id) 
              VALUES (/* $1, $2, ... */) 
              RETURNING id, created_at, updated_at`

	err := dbPool.QueryRow(context.Background(), query /* item fields */).
		Scan(&item.ID, &item.CreatedAt, &item.UpdatedAt)

	if err != nil {
		return Generic{}, err
	}

	return item, nil
}

func GetAll() ([]Generic, error) {
	query := `SELECT generic_table.*, users.name 
              FROM generic_table JOIN users ON generic_table.user_id = users.id`

	rows, err := dbPool.Query(context.Background(), query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var items []Generic
	for rows.Next() {
		var item Generic
		var userName string
		err := rows.Scan(/* &item fields */, &userName)
		if err != nil {
			return nil, err
		}
		item.User = userName
		items = append(items, item)
	}

	return items, rows.Err()
}

func Get(id int) (Generic, error) {
	var item Generic
	var userName string
	query := `SELECT generic_table.*, users.name 
              FROM generic_table JOIN users ON generic_table.user_id = users.id 
              WHERE generic_table.id = $1`
	err := dbPool.QueryRow(context.Background(), query, id).Scan(/* &item fields */, &userName)
	if err != nil {
		return Generic{}, err
	}
	item.User = userName
	return item, nil
}

func Update(item Generic) (Generic, error) {
	query := `UPDATE generic_table SET /* field1=$1, field2=$2, ... */, updated_at=$N 
              WHERE id=$M RETURNING id, created_at, updated_at`
	err := dbPool.QueryRow(context.Background(), query /* item fields */, time.Now(), item.ID).
		Scan(&item.ID, &item.CreatedAt, &item.UpdatedAt)
	if err != nil {
		return Generic{}, err
	}
	return item, nil
}

func Delete(id int) error {
	query := `DELETE FROM generic_table WHERE id=$1`
	_, err := dbPool.Exec(context.Background(), query, id)
	return err
}

func Search(searchTerm string) ([]Generic, error) {
	query := `SELECT generic_table.*, users.name 
              FROM generic_table JOIN users ON generic_table.user_id = users.id 
              WHERE /* field1 ILIKE $1 OR field2 ILIKE $1 ... */`
	rows, err := dbPool.Query(context.Background(), query, "%"+searchTerm+"%")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var items []Generic
	for rows.Next() {
		var item Generic
		var userName string
		err := rows.Scan(/* &item fields */, &userName)
		if err != nil {
			continue
		}
		item.User = userName
		items = append(items, item)
	}
	return items, nil
}

func CloseDBConnection() {
	if dbPool != nil {
		dbPool.Close()
	}
}